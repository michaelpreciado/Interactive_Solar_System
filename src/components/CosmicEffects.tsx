import React, { useRef, useMemo, useEffect } from 'react'
import { useFrame } from '@react-three/fiber'
import * as THREE from 'three'
import { useUIStore } from '../stores/useUIStore'

// Nebula component with particle system
export const Nebula: React.FC<{ 
  position?: [number, number, number]
  scale?: number
  color?: string
  opacity?: number
  particleCount?: number
}> = ({ 
  position = [0, 0, -500], 
  scale = 1, 
  color = '#4A90E2', 
  opacity = 0.3,
  particleCount = 1000
}) => {
  const { performanceSettings, deviceCapabilities } = useUIStore()
  const meshRef = useRef<THREE.Points>(null)
  const materialRef = useRef<THREE.ShaderMaterial>(null)
  
  // Optimize particle count based on device performance
  const optimizedParticleCount = useMemo(() => {
    if (!performanceSettings.enableStarfield) return 0
    
    const baseCount = deviceCapabilities.isMobile ? particleCount * 0.3 : particleCount
    return Math.floor(baseCount * (performanceSettings.starfieldCount / 5000))
  }, [particleCount, deviceCapabilities.isMobile, performanceSettings])
  
  // Create nebula geometry
  const { geometry, material } = useMemo(() => {
    if (optimizedParticleCount === 0) return { geometry: null, material: null }
    
    const geom = new THREE.BufferGeometry()
    const positions = new Float32Array(optimizedParticleCount * 3)
    const colors = new Float32Array(optimizedParticleCount * 3)
    const sizes = new Float32Array(optimizedParticleCount)
    const alphas = new Float32Array(optimizedParticleCount)
    
    const colorObj = new THREE.Color(color)
    
    for (let i = 0; i < optimizedParticleCount; i++) {\n      // Create nebula-like distribution (more dense in center)\n      const radius = Math.random() * 200 + 50\n      const theta = Math.random() * Math.PI * 2\n      const phi = (Math.random() - 0.5) * Math.PI * 0.3 // Flattened distribution\n      \n      positions[i * 3] = radius * Math.cos(theta) * Math.cos(phi)\n      positions[i * 3 + 1] = radius * Math.sin(phi) * 0.3 // Flatten the nebula\n      positions[i * 3 + 2] = radius * Math.sin(theta) * Math.cos(phi)\n      \n      // Color variation\n      const colorVariation = 0.3\n      colors[i * 3] = colorObj.r + (Math.random() - 0.5) * colorVariation\n      colors[i * 3 + 1] = colorObj.g + (Math.random() - 0.5) * colorVariation\n      colors[i * 3 + 2] = colorObj.b + (Math.random() - 0.5) * colorVariation\n      \n      // Varying sizes and opacity\n      sizes[i] = Math.random() * 3 + 1\n      alphas[i] = Math.random() * 0.8 + 0.2\n    }\n    \n    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3))\n    geom.setAttribute('color', new THREE.BufferAttribute(colors, 3))\n    geom.setAttribute('size', new THREE.BufferAttribute(sizes, 1))\n    geom.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1))\n    \n    // Nebula shader material\n    const mat = new THREE.ShaderMaterial({\n      uniforms: {\n        time: { value: 0 },\n        opacity: { value: opacity },\n        scale: { value: scale }\n      },\n      vertexShader: `\n        attribute float size;\n        attribute float alpha;\n        attribute vec3 color;\n        \n        varying vec3 vColor;\n        varying float vAlpha;\n        \n        uniform float time;\n        uniform float scale;\n        \n        void main() {\n          vColor = color;\n          vAlpha = alpha;\n          \n          vec3 pos = position;\n          \n          // Gentle swirling motion\n          float angle = time * 0.1 + length(pos.xz) * 0.01;\n          float c = cos(angle);\n          float s = sin(angle);\n          pos.xz = mat2(c, -s, s, c) * pos.xz;\n          \n          // Vertical drift\n          pos.y += sin(time * 0.05 + pos.x * 0.01) * 2.0;\n          \n          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n          gl_PointSize = size * scale * (1.0 / -mvPosition.z) * 100.0;\n          gl_Position = projectionMatrix * mvPosition;\n        }\n      `,\n      fragmentShader: `\n        varying vec3 vColor;\n        varying float vAlpha;\n        \n        uniform float opacity;\n        \n        void main() {\n          vec2 center = gl_PointCoord - 0.5;\n          float dist = length(center);\n          \n          // Soft circular gradient\n          float alpha = 1.0 - smoothstep(0.0, 0.5, dist);\n          alpha *= vAlpha * opacity;\n          \n          // Add some noise for organic feel\n          float noise = sin(gl_PointCoord.x * 10.0) * sin(gl_PointCoord.y * 10.0) * 0.1 + 0.9;\n          \n          gl_FragColor = vec4(vColor * noise, alpha);\n        }\n      `,\n      transparent: true,\n      blending: THREE.AdditiveBlending,\n      depthWrite: false,\n      vertexColors: true\n    })\n    \n    return { geometry: geom, material: mat }\n  }, [optimizedParticleCount, color, opacity, scale])\n  \n  // Animation\n  useFrame((state) => {\n    if (materialRef.current && performanceSettings.enableAnimations) {\n      materialRef.current.uniforms.time.value = state.clock.elapsedTime\n    }\n  })\n  \n  if (!geometry || !material) return null\n  \n  return (\n    <points\n      ref={meshRef}\n      position={position}\n      geometry={geometry}\n      material={material}\n    >\n      <primitive object={material} ref={materialRef} />\n    </points>\n  )\n}\n\n// Cosmic dust component\nexport const CosmicDust: React.FC<{\n  count?: number\n  radius?: number\n  opacity?: number\n}> = ({ count = 2000, radius = 800, opacity = 0.1 }) => {\n  const { performanceSettings, deviceCapabilities } = useUIStore()\n  const meshRef = useRef<THREE.Points>(null)\n  const materialRef = useRef<THREE.ShaderMaterial>(null)\n  \n  // Optimize dust count\n  const optimizedCount = useMemo(() => {\n    if (!performanceSettings.enableStarfield) return 0\n    \n    const baseCount = deviceCapabilities.isMobile ? count * 0.2 : count\n    return Math.floor(baseCount * (performanceSettings.starfieldCount / 5000))\n  }, [count, deviceCapabilities.isMobile, performanceSettings])\n  \n  const { geometry, material } = useMemo(() => {\n    if (optimizedCount === 0) return { geometry: null, material: null }\n    \n    const geom = new THREE.BufferGeometry()\n    const positions = new Float32Array(optimizedCount * 3)\n    const velocities = new Float32Array(optimizedCount * 3)\n    const sizes = new Float32Array(optimizedCount)\n    \n    for (let i = 0; i < optimizedCount; i++) {\n      // Random spherical distribution\n      const r = Math.random() * radius + radius * 0.5\n      const theta = Math.random() * Math.PI * 2\n      const phi = Math.acos(Math.random() * 2 - 1)\n      \n      positions[i * 3] = r * Math.sin(phi) * Math.cos(theta)\n      positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta)\n      positions[i * 3 + 2] = r * Math.cos(phi)\n      \n      // Small random velocities for gentle movement\n      velocities[i * 3] = (Math.random() - 0.5) * 0.1\n      velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.05\n      velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.1\n      \n      sizes[i] = Math.random() * 0.5 + 0.1\n    }\n    \n    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3))\n    geom.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3))\n    geom.setAttribute('size', new THREE.BufferAttribute(sizes, 1))\n    \n    const mat = new THREE.ShaderMaterial({\n      uniforms: {\n        time: { value: 0 },\n        opacity: { value: opacity }\n      },\n      vertexShader: `\n        attribute float size;\n        attribute vec3 velocity;\n        \n        uniform float time;\n        \n        varying float vOpacity;\n        \n        void main() {\n          vec3 pos = position + velocity * time;\n          \n          // Fading based on distance from origin\n          float dist = length(pos) / 1000.0;\n          vOpacity = 1.0 - smoothstep(0.5, 1.0, dist);\n          \n          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n          gl_PointSize = size * (1.0 / -mvPosition.z) * 50.0;\n          gl_Position = projectionMatrix * mvPosition;\n        }\n      `,\n      fragmentShader: `\n        uniform float opacity;\n        varying float vOpacity;\n        \n        void main() {\n          vec2 center = gl_PointCoord - 0.5;\n          float dist = length(center);\n          \n          float alpha = 1.0 - smoothstep(0.0, 0.5, dist);\n          alpha *= vOpacity * opacity;\n          \n          gl_FragColor = vec4(0.8, 0.9, 1.0, alpha);\n        }\n      `,\n      transparent: true,\n      blending: THREE.AdditiveBlending,\n      depthWrite: false\n    })\n    \n    return { geometry: geom, material: mat }\n  }, [optimizedCount, radius, opacity])\n  \n  useFrame((state) => {\n    if (materialRef.current && performanceSettings.enableAnimations) {\n      materialRef.current.uniforms.time.value = state.clock.elapsedTime * 0.1\n    }\n  })\n  \n  if (!geometry || !material) return null\n  \n  return (\n    <points\n      ref={meshRef}\n      geometry={geometry}\n      material={material}\n    >\n      <primitive object={material} ref={materialRef} />\n    </points>\n  )\n}\n\n// Solar wind effect\nexport const SolarWind: React.FC<{\n  particleCount?: number\n  speed?: number\n  opacity?: number\n}> = ({ particleCount = 500, speed = 1, opacity = 0.15 }) => {\n  const { performanceSettings, deviceCapabilities } = useUIStore()\n  const meshRef = useRef<THREE.Points>(null)\n  const materialRef = useRef<THREE.ShaderMaterial>(null)\n  \n  const optimizedCount = useMemo(() => {\n    if (!performanceSettings.enableStarfield) return 0\n    return deviceCapabilities.isMobile ? particleCount * 0.3 : particleCount\n  }, [particleCount, deviceCapabilities.isMobile, performanceSettings])\n  \n  const { geometry, material } = useMemo(() => {\n    if (optimizedCount === 0) return { geometry: null, material: null }\n    \n    const geom = new THREE.BufferGeometry()\n    const positions = new Float32Array(optimizedCount * 3)\n    const phases = new Float32Array(optimizedCount)\n    const speeds = new Float32Array(optimizedCount)\n    \n    for (let i = 0; i < optimizedCount; i++) {\n      // Start particles near the sun\n      const angle = Math.random() * Math.PI * 2\n      const radius = 5 + Math.random() * 10\n      \n      positions[i * 3] = Math.cos(angle) * radius\n      positions[i * 3 + 1] = (Math.random() - 0.5) * 5\n      positions[i * 3 + 2] = Math.sin(angle) * radius\n      \n      phases[i] = Math.random() * Math.PI * 2\n      speeds[i] = 0.5 + Math.random() * 1.5\n    }\n    \n    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3))\n    geom.setAttribute('phase', new THREE.BufferAttribute(phases, 1))\n    geom.setAttribute('speed', new THREE.BufferAttribute(speeds, 1))\n    \n    const mat = new THREE.ShaderMaterial({\n      uniforms: {\n        time: { value: 0 },\n        opacity: { value: opacity },\n        speed: { value: speed }\n      },\n      vertexShader: `\n        attribute float phase;\n        attribute float speed;\n        \n        uniform float time;\n        uniform float speed as globalSpeed;\n        \n        varying float vDistance;\n        varying float vIntensity;\n        \n        void main() {\n          vec3 pos = position;\n          \n          // Radial outward movement from sun\n          vec3 direction = normalize(pos);\n          pos += direction * time * globalSpeed * speed;\n          \n          // Add some turbulence\n          pos.x += sin(time * 2.0 + phase) * 0.5;\n          pos.z += cos(time * 1.5 + phase) * 0.5;\n          \n          vDistance = length(pos);\n          vIntensity = 1.0 / (1.0 + vDistance * 0.01);\n          \n          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n          gl_PointSize = 2.0 * vIntensity * 100.0 / -mvPosition.z;\n          gl_Position = projectionMatrix * mvPosition;\n        }\n      `,\n      fragmentShader: `\n        uniform float opacity;\n        varying float vDistance;\n        varying float vIntensity;\n        \n        void main() {\n          vec2 center = gl_PointCoord - 0.5;\n          float dist = length(center);\n          \n          float alpha = 1.0 - smoothstep(0.0, 0.5, dist);\n          alpha *= vIntensity * opacity;\n          \n          // Solar wind color (yellow-white)\n          vec3 color = mix(vec3(1.0, 1.0, 0.8), vec3(1.0, 0.9, 0.7), vIntensity);\n          \n          gl_FragColor = vec4(color, alpha);\n        }\n      `,\n      transparent: true,\n      blending: THREE.AdditiveBlending,\n      depthWrite: false\n    })\n    \n    return { geometry: geom, material: mat }\n  }, [optimizedCount, speed, opacity])\n  \n  useFrame((state) => {\n    if (materialRef.current && performanceSettings.enableAnimations) {\n      materialRef.current.uniforms.time.value = state.clock.elapsedTime\n      \n      // Reset particles that have gone too far\n      if (geometry) {\n        const positions = geometry.attributes.position.array as Float32Array\n        const time = state.clock.elapsedTime\n        \n        for (let i = 0; i < optimizedCount; i++) {\n          const x = positions[i * 3]\n          const y = positions[i * 3 + 1]\n          const z = positions[i * 3 + 2]\n          const distance = Math.sqrt(x * x + y * y + z * z)\n          \n          // Reset particle if it's too far\n          if (distance > 500) {\n            const angle = Math.random() * Math.PI * 2\n            const radius = 5 + Math.random() * 10\n            \n            positions[i * 3] = Math.cos(angle) * radius\n            positions[i * 3 + 1] = (Math.random() - 0.5) * 5\n            positions[i * 3 + 2] = Math.sin(angle) * radius\n          }\n        }\n        \n        geometry.attributes.position.needsUpdate = true\n      }\n    }\n  })\n  \n  if (!geometry || !material) return null\n  \n  return (\n    <points\n      ref={meshRef}\n      geometry={geometry}\n      material={material}\n    >\n      <primitive object={material} ref={materialRef} />\n    </points>\n  )\n}\n\n// Main cosmic effects container\nexport const CosmicEffects: React.FC = () => {\n  const { performanceSettings } = useUIStore()\n  \n  if (!performanceSettings.enableStarfield) return null\n  \n  return (\n    <>\n      {/* Multiple nebulae for depth */}\n      <Nebula \n        position={[-300, 50, -400]} \n        color=\"#4A90E2\" \n        opacity={0.2}\n        scale={0.8}\n        particleCount={800}\n      />\n      <Nebula \n        position={[400, -30, -600]} \n        color=\"#E24A90\" \n        opacity={0.15}\n        scale={1.2}\n        particleCount={600}\n      />\n      <Nebula \n        position={[0, 200, -800]} \n        color=\"#90E24A\" \n        opacity={0.1}\n        scale={1.5}\n        particleCount={1000}\n      />\n      \n      {/* Cosmic dust */}\n      <CosmicDust count={1500} radius={600} opacity={0.08} />\n      \n      {/* Solar wind effect */}\n      <SolarWind particleCount={300} speed={2} opacity={0.1} />\n    </>\n  )\n}